Account — Resource

Method — POST

URI : /Account/{accountNumber}/Transaction

Request Body
{
	“amount” : 10000,
	“operation” : Deposit,
	“state”: “new” //success,failure
}

——>. Msg —> Listener —> call debit/credit

—> 
——————————————————


Debit/ Credit  — > Balance in the account 


———————————————————

Node head = anyNode. 
Traverse our linked list list 
If (head)
Sysout(“Yes”);

——————————————————

1->2->3 
       \     |
         \   |
           6

List<Node> nodes = LinkedList<Node>();
Set<Node> traversed = new HashSet<>();
Iterate thru Nodes
Traversed.put(node)
if(traversed.containes(node.next))
	Sysout(“YES”);



-------------------------------------------------------------------------

Snake ladder N*N 


a[100]
10*10 
[
 0 1 2 3 4 5 6 
 
		55

 97 98 99
]

doublyLinkedList

————————————————————

Music Playlist — 
		createPlayList(List<Song> songs)
		add (Song s)
		remove (Song s)
		deletePlayList(String playList id)
		reshuffle(playListId)
		moveUp(Song s)
		moveDown(Song s)
		update(playListId, List<Song> songs)

HashMap(playListId,LinkedList<Songs> Songs)

Song0 <—> Song1 <—> Song2 <—> Song3 <—> Song4 <—> Song5 

——————————————————————————



List<List<String>> bucketAnagrams(List<String> words);
   Input:  {"now", "god", "something", "won", "onw", "dog", "no"}
   Output: { {"now", "won", “onw”}, {"god", "dog"}, {"something"}, {"no"}}

for(int I=0;i<s.length;i++)
{
	List<String> s = new ArrayList<>();
	s.add(s[I]);
	for(j=I+1;j<s.lenth;j++)
		{
			if(s[I].length == s[j].length)
				if(checkcharacters(s[I],[s[j]))

					s.add[j]; // remove that String from the array
		}
}

checkCharacters(String s,String s2)
{
	//Check the characters in both if same return true else false.
	count down characters — 

}

——————————————————————————————

try { Thread.sleep(10); } catch (InterruptedException e) { }

—————————————————————————
SOLID


BinarySearch

Public int binarySearch(int []arr, int element)
{
	int len = arr.length;
	int pos = -1;
	for(int i=0; I<len;i++)
	{
		mid = arr.length/2;

		if(element > arr[mid])
			i = mid+1;
		else if (element < arr[mid])
			len = mid;
		
		else if (element == arr[mid]
			pos = mid;
	} 
	
	return pos	

}		


++ , —, << , >>,& , |

Unsigned int x ; //4 bytes
Public int countOfones (int x)
{
	int number = 0;
	// do or operation on with zero then whenever result is true then it’s one otherwise its zero

	int bit = >>x;

	return count;	
}

—————————————————————————————————————
‘AAAAAAABBBBBBB’. ‘AB’
[A,A]
[A,A]  [A,B]

[A,B] [A,B]
Public int substring (String s1, String s2)
{
	Character [] ch = s2.toCharArray ();
	Character [] ch2 = s1.toCharArray ();
	for(int i=0;i<ch2.length;i++)
	{
	  if(Arrays.equals(ch,subStringString(int point, int 2));)
			return point;
	}



}

Public String subStringString(int point, int length)
{
 Character [] ch = s1.toCharArray ();
 for(int I=point;I<chlenght;point++)
	newch[I] = ch[I];
Return newch;
}


——————————————————————————————————————
List<Integer> l = new LinkedList<Integer>();


1->2->3->4->5->null

5->4->3->2->1->null

Cur = l;
While(l.next()!=null)
{
	cur = l;
	cur.next = l.next();	
}

———————————————————————————————————————

Int pplcount. = 1000;

Int vaccinationfreq = 4;

Age  — <10 and >60 

Person {
	AdharId;
	Age;
	vaccinCount;
	lastVaccinatedDate;
}


————————————————————————————————————

Mirror a tree


    5
   /.  \
2.    3
/.  \.   \ 
1.   0.  4 

    5
   /	\
3.     2
/     /.   \
4.  0.   1


Public Node mirror (Node node){
       Node temp;
       temp = node;
	Stack<Node> routeNodes;
	Set<Node> uniqueNodes;

      while( temp!=null)
	{
		
		if(temp.left!=null){
			temp = Node.left;
			routeNodes.push(temp); 		}
		else if(temp.right!=null)
			{
				temp =  Node.right;
				routeNodes.push(temp);
			}
		else{
			Node prev = routeNodes.pop()
			Node tem1 = prev.right;
			prev.right  = prev.left;
			prev.left = temp1;
			temp = routeNodes.pop();
		}

	}
Return routeNode;
}


—————————————————————————————————————————————————
Given String

String s = “abcd”;
Abcd
Acbd
Acdb

[a,b,c,d]

Void permutation(String s, int l, int r)
{
	If( l == r)
		Sysout(str);		
	else
	{
		for(int I=l;i<=r;i++)
		{
			str = swap (str, l, I);
			permutation(str1,l+1;r)
			str = swap(str, l, i);
		}
	}
}	

String swap(String a, int I, int j)
{

  	Char temp;
	Char[] charArray = a.toCharArray();
	Temp = charrArry[I];
	charrArry[I] = charArrya[j];
	charArray[j] = temp;

Return string.value(charArray);
}

















		



